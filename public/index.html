<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Generador aleatorio (Canvas) — Texto en recuadro animado</title>
  <style>
    :root{font-family: Inter, system-ui, Arial, sans-serif}
    body{margin:0;display:flex;flex-direction:column;height:100vh}
    #controls{display:flex;gap:10px;padding:12px;background:#0f172a;color:#fff;align-items:center}
    #controls input[type=text]{padding:8px 10px;border-radius:6px;border:1px solid rgba(255,255,255,0.12);min-width:220px}
    #controls button{padding:8px 12px;border-radius:6px;border:none;background:#06b6d4;color:#042;cursor:pointer}
    #controls button.secondary{background:#94a3b8;color:#042}
    #stage{flex:1;display:flex;align-items:center;justify-content:center;background:#111}
    canvas{background:transparent;max-width:100%;max-height:100%;border-radius:8px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
    .hint{color:#94a3b8;font-size:12px;margin-left:8px}
    footer{padding:8px 12px;font-size:12px;color:#94a3b8;background:#071127}
  </style>
</head>
<body>
  <div id="controls">
    <label style="display:flex;align-items:center;gap:8px">
      <span>Texto:</span>
      <input id="textInput" type="text" value="Hola mundo" />
    </label>
    <button id="generateBtn">Generar</button>
    <button id="downloadBtn" class="secondary">Descargar animación (15s)</button>
    <div class="hint">Duración: 15s • Cada "Generar" reinicia la animación y el lienzo</div>
  </div>

  <div id="stage">
    <canvas id="c"></canvas>
  </div>

  <footer>Canvas real • Animaciones random para fondo, recuadro y texto • Grabador WebM</footer>

<script>
// Config
const DURATION = 15000; // 15 segundos en ms
const FPS = 60;

// Canvas setup
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
function fitCanvas() {
  const ratio = window.devicePixelRatio || 1;
  const w = Math.min(window.innerWidth - 60, 1200);
  const h = Math.min(window.innerHeight - 160, 700);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  canvas.width = Math.round(w * ratio);
  canvas.height = Math.round(h * ratio);
  ctx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', fitCanvas);
fitCanvas();

// UI
const textInput = document.getElementById('textInput');
const generateBtn = document.getElementById('generateBtn');
const downloadBtn = document.getElementById('downloadBtn');

let animationId = null;
let animationStart = 0;
let currentSpec = null; // random spec for this run

// Helpers
function rand(min, max){ return Math.random()*(max-min)+min }
function randInt(min,max){ return Math.floor(rand(min,max+1)) }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)] }
function lerp(a,b,t){ return a + (b-a)*t }
function easeInOutQuad(t){ return t<0.5?2*t*t: -1 + (4-2*t)*t }
function hslToCss(h,s,l){ return `hsl(${h} ${s}% ${l}%)` }

// Create a random color
function randomColor(hRange=[0,360], sRange=[40,90], lRange=[30,70]){
  return {
    h: randInt(hRange[0], hRange[1]),
    s: randInt(sRange[0], sRange[1]),
    l: randInt(lRange[0], lRange[1])
  }
}
function colorCss(c){ return `hsl(${c.h} ${c.s}% ${c.l}%)` }

// Create random animation spec (one-time per Generate click)
function createSpec(text){
  // background: either solid, radial gradient or animated stripes
  const bgType = pick(['solid','gradient','stripes','noise']);

  const bg = {
    type: bgType,
    colors: [randomColor(), randomColor(), randomColor()],
    angle: rand(0,360),
    speed: rand(0.1,1.5) // affects subtle motion
  }

  // box (recuadro) spec
  const box = {
    xRel: rand(0.25,0.75),
    yRel: rand(0.35,0.65),
    wRel: rand(0.35,0.75),
    hRel: rand(0.12,0.28),
    round: rand(6,60),
    color: randomColor([0,360],[30,90],[30,70]),
    borderColor: randomColor([0,360],[20,60],[10,40]),
    startTransform: {tx: rand(-80,80), ty: rand(-40,40), rot: rand(-20,20), scale: rand(0.7,1.3), opacity: rand(0.2,0.8)},
    endTransform:   {tx: rand(-40,40), ty: rand(-20,20), rot: rand(-60,60), scale: rand(0.8,1.6), opacity: rand(0.4,1)}
  }

  // text spec
  const fontFamilies = ['Inter','Arial','Verdana','Georgia','Impact','Segoe UI','Tahoma'];
  const textSpec = {
    content: text || 'Hola mundo',
    fontFamily: pick(fontFamilies),
    fontSize: rand(36,110),
    color: randomColor([0,360],[40,100],[20,85]),
    shadow: {x: rand(-12,12), y: rand(-12,12), blur: rand(6,30), color: randomColor([0,360],[10,60],[10,30])},
    startTransform: {tx: rand(-120,120), ty: rand(-80,80), rot: rand(-45,45), scale: rand(0.6,1.6), opacity: rand(0.2,0.9)},
    endTransform:   {tx: rand(-40,40), ty: rand(-30,30), rot: rand(-180,180), scale: rand(0.6,2.2), opacity: rand(0.4,1)}
  }

  // combined
  return {bg, box, text: textSpec, duration: DURATION}
}

// Draw functions
function drawBackground(spec, t){
  const w = canvas.width/ (window.devicePixelRatio || 1);
  const h = canvas.height/ (window.devicePixelRatio || 1);
  ctx.save();
  ctx.clearRect(0,0,w,h);

  if(spec.bg.type === 'solid'){
    ctx.fillStyle = colorCss(spec.bg.colors[0]);
    ctx.fillRect(0,0,w,h);
  } else if(spec.bg.type === 'gradient'){
    // animate angle slightly
    const angle = spec.bg.angle + spec.bg.speed * t * 20;
    const x = Math.cos(angle*Math.PI/180);
    const y = Math.sin(angle*Math.PI/180);

    const g = ctx.createLinearGradient( (0.5-x)*w, (0.5-y)*h, (0.5+x)*w, (0.5+y)*h );
    g.addColorStop(0, colorCss(spec.bg.colors[0]));
    g.addColorStop(0.5, colorCss(spec.bg.colors[1]));
    g.addColorStop(1, colorCss(spec.bg.colors[2]));
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  } else if(spec.bg.type === 'stripes'){
    // moving diagonal stripes
    ctx.fillStyle = colorCss(spec.bg.colors[0]);
    ctx.fillRect(0,0,w,h);
    const stripeW = 40 + Math.abs(Math.sin(t*spec.bg.speed))*80;
    const offset = (t * spec.bg.speed * 200) % (stripeW*2);
    ctx.save();
    ctx.translate(-offset,0);
    for(let i=-2;i< w/stripeW + 10;i++){
      ctx.fillStyle = i%2? colorCss(spec.bg.colors[1]) : colorCss(spec.bg.colors[2]);
      ctx.beginPath();
      ctx.rect(i*stripeW,0,stripeW/1.5,h);
      ctx.fill();
    }
    ctx.restore();
  } else {
    // noise-ish: radial blends
    const g = ctx.createRadialGradient(w*0.2,h*0.2,50,w*0.8,h*0.8,Math.max(w,h));
    g.addColorStop(0, colorCss(spec.bg.colors[0]));
    g.addColorStop(0.7, colorCss(spec.bg.colors[1]));
    g.addColorStop(1, colorCss(spec.bg.colors[2]));
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }
  ctx.restore();
}

function drawBox(spec, tProgress){
  const w = canvas.width/ (window.devicePixelRatio || 1);
  const h = canvas.height/ (window.devicePixelRatio || 1);

  const bx = spec.box.xRel * w;
  const by = spec.box.yRel * h;
  const bw = spec.box.wRel * w;
  const bh = spec.box.hRel * h;

  const st = spec.box.startTransform;
  const en = spec.box.endTransform;

  // transform interpolation
  const tx = lerp(st.tx, en.tx, tProgress);
  const ty = lerp(st.ty, en.ty, tProgress);
  const rot = lerp(st.rot, en.rot, tProgress) * Math.PI/180;
  const scale = lerp(st.scale, en.scale, tProgress);
  const opacity = lerp(st.opacity, en.opacity, tProgress);

  ctx.save();
  ctx.globalAlpha = opacity;
  ctx.translate(bx + bw/2 + tx, by + bh/2 + ty);
  ctx.rotate(rot);
  ctx.scale(scale, scale);

  // fill
  ctx.beginPath();
  roundRect(ctx, -bw/2, -bh/2, bw, bh, spec.box.round);
  ctx.fillStyle = colorCss(spec.box.color);
  ctx.fill();
  // border
  ctx.lineWidth = Math.max(2, Math.min(10, bw*0.01));
  ctx.strokeStyle = colorCss(spec.box.borderColor);
  ctx.stroke();

  ctx.restore();
}

function drawText(spec, tProgress){
  const w = canvas.width/ (window.devicePixelRatio || 1);
  const h = canvas.height/ (window.devicePixelRatio || 1);

  const bx = spec.box.xRel * w;
  const by = spec.box.yRel * h;
  const bw = spec.box.wRel * w;
  const bh = spec.box.hRel * h;

  const st = spec.text.startTransform;
  const en = spec.text.endTransform;
  const tx = lerp(st.tx, en.tx, tProgress);
  const ty = lerp(st.ty, en.ty, tProgress);
  const rot = lerp(st.rot, en.rot, tProgress) * Math.PI/180;
  const scale = lerp(st.scale, en.scale, tProgress);
  const opacity = lerp(st.opacity, en.opacity, tProgress);

  const content = spec.text.content;
  // responsive font size base
  let fontSize = spec.text.fontSize;
  // clamp to available box
  const maxWidth = bw * 0.9;
  ctx.save();
  ctx.translate(bx + bw/2 + tx, by + bh/2 + ty);
  ctx.rotate(rot);
  ctx.scale(scale, scale);
  ctx.globalAlpha = opacity;

  // shadow
  const sh = spec.text.shadow;
  ctx.shadowOffsetX = sh.x;
  ctx.shadowOffsetY = sh.y;
  ctx.shadowBlur = sh.blur;
  ctx.shadowColor = colorCss(sh.color);

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';

  // adapt font size so text fits
  ctx.font = `bold ${fontSize}px ${spec.text.fontFamily}`;
  let measured = ctx.measureText(content).width;
  if(measured > maxWidth){
    const factor = maxWidth / measured;
    fontSize = Math.floor(fontSize * factor);
    ctx.font = `bold ${fontSize}px ${spec.text.fontFamily}`;
  }

  ctx.fillStyle = colorCss(spec.text.color);
  ctx.fillText(content, 0, 0);

  // small animated outline
  ctx.lineWidth = Math.max(1, Math.floor(fontSize*0.06));
  ctx.strokeStyle = `rgba(0,0,0,0.12)`;
  ctx.strokeText(content,0,0);

  ctx.restore();
}

// Utility to draw rounded rect path
function roundRect(ctx, x, y, w, h, r){
  const rad = Math.min(r, Math.min(w/2,h/2));
  ctx.beginPath();
  ctx.moveTo(x+rad, y);
  ctx.arcTo(x+w, y, x+w, y+h, rad);
  ctx.arcTo(x+w, y+h, x, y+h, rad);
  ctx.arcTo(x, y+h, x, y, rad);
  ctx.arcTo(x, y, x+w, y, rad);
  ctx.closePath();
}

// Animation loop
function startAnimation(spec){
  cancelAnimationFrame(animationId);
  animationStart = performance.now();
  currentSpec = spec;

  function frame(now){
    const elapsed = now - animationStart;
    const t = Math.min(1, elapsed / spec.duration);
    const eased = easeInOutQuad(t);

    // draw background based on elapsed in seconds
    drawBackground(spec, elapsed / 1000);
    // draw box and text
    drawBox(spec, eased);
    drawText(spec, eased);

    if(elapsed >= spec.duration){
      // finish and stop loop (keeps final frame)
      cancelAnimationFrame(animationId);
      animationId = null;
      return;
    }
    animationId = requestAnimationFrame(frame);
  }
  animationId = requestAnimationFrame(frame);
}

// Generate handler — reinicia el canvas y crea una nueva animacion random
function handleGenerate(){
  // Reiniciar (detener animaciones previas)
  if(animationId) cancelAnimationFrame(animationId);
  // create spec and start
  const spec = createSpec(textInput.value.trim() || ' ');
  startAnimation(spec);
}

generateBtn.addEventListener('click', handleGenerate);

// Start an initial animation
handleGenerate();

// Recording / Download
let recorder = null;
let recordedChunks = [];

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000*60);
}

async function handleDownload(){
  // If no currentSpec, just inform
  if(!currentSpec){
    alert('No hay animación para grabar. Pulsa Generar primero.');
    return;
  }

  // Ensure the animation is running from the start for a faithful recording.
  // We'll restart the animation and record the next 15s.
  if(animationId) cancelAnimationFrame(animationId);
  recordedChunks = [];

  // Restart animation timeline from zero using the same spec
  const spec = currentSpec;
  startAnimation(spec);

  const stream = canvas.captureStream(FPS);
  recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=vp9' });

  recorder.ondataavailable = function(e){ if(e.data && e.data.size) recordedChunks.push(e.data); };
  recorder.onstop = function(){
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    downloadBlob(blob, `animacion_${Date.now()}.webm`);
  };

  recorder.start();
  downloadBtn.disabled = true;
  downloadBtn.textContent = 'Grabando... (15s)';

  // stop recording after the animation duration
  setTimeout(()=>{
    if(recorder && recorder.state === 'recording') recorder.stop();
    downloadBtn.disabled = false;
    downloadBtn.textContent = 'Descargar animación (15s)';
  }, DURATION + 200); // add tiny buffer
}

downloadBtn.addEventListener('click', handleDownload);

// Accessibility: allow Enter to generate
textInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') handleGenerate(); });

</script>
</body>
  </html>
  
